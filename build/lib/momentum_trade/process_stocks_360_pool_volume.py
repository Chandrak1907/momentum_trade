import loggingimport pandas as pdimport datetimefrom datetime import dateimport bs4 as bsimport requestsfrom scipy import statsimport numpy as npfrom pandas_datareader import data as pdrfrom gspread_pandas import Spread, Client, confimport timeboard.calendars.US as USimport portfolio_variablesimport osimport reimport picklefrom pathlib import Pathimport hurstimport nsepydef get_nse_list():    """ Function for getting list of NSE symbols from a sample_bhavcopy    This function need to be rewritten to dynamically get list of NSE symbols traded    """    bhavcopy = pd.read_csv("../csvs_n_tokens/sample_bhavcopy.csv")    tickers = bhavcopy.SYMBOL.values.tolist()    return tickersdef get_all_nasdaq_symbols():    """ Function for getting list of NASDAQ symbols using pandas datareader    """        all_symbols = pdr.get_nasdaq_symbols()    Stocks = all_symbols[(all_symbols.ETF==False) & (all_symbols['Test Issue'] ==False) & (all_symbols['Financial Status']=='N')]    return list(Stocks.index)def get_start_date(duration_days = portfolio_variables.PAST_DURATION):    """ Function for getting data ranges to create list of momentum stocks    """        duration = datetime.timedelta(days = duration_days)    end_date = datetime.datetime.now()    start_date = pd.Timestamp(end_date-duration)    days = np.busday_count(start_date.date(),end_date.date())    while(days<=400):        duration_days+=1        duration = datetime.timedelta(days = duration_days)        start_date = pd.Timestamp(end_date-duration)        days = np.busday_count( start_date.date(), end_date.date() )    return(start_date, end_date)def get_tickers_from_csv():    """ This function needs to be deleted    """        watchlist = pd.read_csv(os.fsdecode("../logs/tmp/tmp.csv"),skip_blank_lines=True,header=2)    tickers= [s.replace('\t','').strip() for s in watchlist.Symbol.values]    tickers = [sym for sym in tickers if not re.search('[p]', sym)]    return tickersdef get_sp500_tickers():    """ Function for getting list of S&P 500 symbols from wikipedia    """        resp = requests.get('http://en.wikipedia.org/wiki/List_of_S%26P_500_companies')    soup = bs.BeautifulSoup(resp.text, 'lxml')    table = soup.find('table', {'class': 'wikitable sortable'})    tickers = []    for row in table.findAll('tr')[1:]:        ticker = row.findAll('td')[0].text        ticker = ticker.replace('\n','')        tickers.append(ticker)    return tickersclass stock:    """ Base class for representing any ticker from any exchange (NASDAQ/NSE/NYSE)    This base class is used by tickers from US and Indian stock exchanges    """        def __init__(self,symbol,start_date=None, end_date=None, data=None):        self.symbol= symbol        self.data = data        self.start_date =get_start_date()[0]        self.end_date = get_start_date()[1]        print("... ",symbol, self.start_date, self.end_date)        self.adjusted_slope_30 =None        self.adjusted_slope_90 =None        self.adjusted_slope_180 =None        self.adjusted_slope_360 =None        self.Hurst = None        self.Hurst_vol = None        self.adjusted_slope_30_vol =None        self.adjusted_slope_90_vol =None        self.adjusted_slope_180_vol =None        self.adjusted_slope_360_vol =None        self.to_consider=False        self.MA_100 = None        self.MA_50 = None        self.ATR_20 = None        self.position_size = None        self.Adj_Close= None        self.Volume = None        self.close_gt_ma100 = None        self.ma50_gt_ma100 = None        self.max_min = None        self.could_process = True        self.download_dates = None    def get_stock_data(self):        ''' Super function for getting data '''        pass    def create_stats(self):        """ Function for creating Moving Averages """        self.data = self.data.sort_values(['Date'])        if(self.country == 'US'):            self.data['Close_Shift'] = self.data['Adj Close'].shift(1)            self.data['100_days_MA'] = self.data["Adj Close"].rolling(window=100).mean()            self.data['50_days_MA'] = self.data["Adj Close"].rolling(window=50).mean()        else:            self.data['Close_Shift'] = self.data['Close'].shift(1)            self.data['100_days_MA'] = self.data["Close"].rolling(window=100).mean()            self.data['50_days_MA'] = self.data["Close"].rolling(window=50).mean()        self.data['TR'] = self.data[['High','Close_Shift']].max(axis=1) - self.data[['Low','Close_Shift']].min(axis=1)         self.data['20_days_TR'] = self.data["TR"].rolling(window=20).mean()        if(self.country== 'US'):            self.data = self.data[['Date', 'High', 'Low', 'Open', 'Close','Volume', 'Adj Close', 'Close_Shift', 'TR', '100_days_MA', '50_days_MA','20_days_TR']]        else:            self.data = self.data[['Date', 'High', 'Low', 'Open', 'Close','Volume', 'Close_Shift', 'TR', '100_days_MA', '50_days_MA','20_days_TR']]        self.data.to_csv("../stocks_history/"+self.symbol+".csv",index=False)            def fit_curve2(self, time_period,col):        if(self.data is not None):            if(self.data.shape[0] >= time_period):                log_series = np.log(self.data.iloc[-time_period:,][col].astype(float))                x_axis=np.arange(0,len(log_series))+1                slope, intercept, r_value, p_value, std_err = stats.linregress(x_axis, log_series)                annualized_slope = np.power(np.exp(slope),250)-1                adjusted_slope = annualized_slope * (r_value**2)            else:                self.could_process = False                adjusted_slope = 0        else:            self.could_process = False            adjusted_slope = 0        return adjusted_slope    def fit_curve(self, time_period,col):        try:            if(self.data is not None):                if(self.data.shape[0] >= time_period):                    log_series = np.log(self.data.iloc[-time_period:,][col].astype(float))                    x_axis=np.arange(0,len(log_series))+1                    slope, intercept, r_value, p_value, std_err = stats.linregress(x_axis, log_series)                    annualized_slope = np.power(np.exp(slope),250)-1                    adjusted_slope = annualized_slope * (r_value**2)                else:                    self.could_process = False                    adjusted_slope = 0            else:                self.could_process = False                adjusted_slope = 0        except Exception as e:            print(self.symbol,"Problem in fit_curve ... ",e)        return adjusted_slope    def get_hurst(self, col):        if(self.data is not None):            try:                H, c, data = hurst.compute_Hc(self.data[[col]], kind='price', simplified=True)                if(H is not None):                    self.Hurst = round(H,2)                else:                    self.could_process = False                    self.Hurst = -1.0            except Exception as e:                self.could_process = False                print(self.symbol,"Hurst is not working .. ",e)    def check_file(self):        date_pairs =[]        my_file = Path("../stocks_history/"+self.symbol+".csv")        if my_file.is_file():            df = pd.read_csv("../stocks_history/"+self.symbol+".csv")            if(df.shape[0]>10):                self.data = df                min_date = pd.to_datetime(df.Date.min(), format='%Y-%m-%d') + pd.Timedelta('1 days')                max_date = pd.to_datetime(df.Date.max(), format='%Y-%m-%d') + pd.Timedelta('1 days')                if(min_date > self.start_date):                    date_pairs.append([self.start_date, min_date])                if(max_date < self.end_date):                    date_pairs.append([ max_date,self.end_date])        else:            date_pairs.append([self.start_date, self.end_date])        self.download_dates = date_pairs            def get_adjusted_slope2(self, port_folio_value= 100000, risk_factor = 0.001):        if(self.country=='US'):            self.adjusted_slope_30 = self.fit_curve(30, 'Adj Close')            self.adjusted_slope_90 = self.fit_curve(90, 'Adj Close')            self.adjusted_slope_180 = self.fit_curve(180, 'Adj Close')            self.adjusted_slope_360 = self.fit_curve(360, 'Adj Close')            self.get_hurst('Adj Close')        else:            self.adjusted_slope_30 = self.fit_curve(30, 'Close')            self.adjusted_slope_90 = self.fit_curve(90, 'Close')            self.adjusted_slope_180 = self.fit_curve(180, 'Close')            self.adjusted_slope_360 = self.fit_curve(360, 'Close')            self.get_hurst('Close')        self.adjusted_slope_30_vol = self.fit_curve(30, 'Volume')        self.adjusted_slope_90_vol = self.fit_curve(90, 'Volume')        self.adjusted_slope_180_vol = self.fit_curve(180, 'Volume')        self.adjusted_slope_360_vol = self.fit_curve(360, 'Volume')        self.get_hurst('Volume')        self.ATR_20 = self.data['20_days_TR'].iloc[-1]        self.MA_100 = self.data['100_days_MA'].iloc[-1]        self.MA_50 = self.data['50_days_MA'].iloc[-1]        if(self.country=='US'):            self.Adj_Close = self.data['Adj Close'].iloc[-1]            min_90 = self.data.iloc[-90:,]['Adj Close'].min()            max_90 = self.data.iloc[-90:,]['Adj Close'].max()        else:            self.Adj_Close = self.data['Close'].iloc[-1]            min_90 = self.data.iloc[-90:,]['Close'].min()            max_90 = self.data.iloc[-90:,]['Close'].max()        self.Volume = self.data['Volume'].iloc[-1]        self.close_gt_ma100 = True if self.Adj_Close >= self.MA_100 else False        self.ma50_gt_ma100 = True if self.MA_50 >= self.MA_100 else False        self.max_min =  max_90/min_90         self.position_size = np.round((port_folio_value*risk_factor )/(self.data['20_days_TR'].iloc[-1]))        if((self.close_gt_ma100) & (self.ma50_gt_ma100)  ):                self.to_consider = True        return([self.symbol,self.to_consider,self.could_process, round(self.Adj_Close,2),round(self.adjusted_slope_30,2),round(self.adjusted_slope_90,2),round(self.adjusted_slope_180,2),round(self.adjusted_slope_360,2), self.Hurst,round(self.ATR_20,2),round(self.MA_100,2),self.position_size,self.Volume,self.close_gt_ma100,self.ma50_gt_ma100,self.max_min, round(self.adjusted_slope_30_vol,2),round(self.adjusted_slope_90_vol,2),round(self.adjusted_slope_180_vol,2),round(self.adjusted_slope_360_vol,2)])    def get_adjusted_slope(self, port_folio_value= 100000, risk_factor = 0.001):        try:            if(self.country=='US'):                self.adjusted_slope_30 = self.fit_curve(30, 'Adj Close')                self.adjusted_slope_90 = self.fit_curve(90, 'Adj Close')                self.adjusted_slope_180 = self.fit_curve(180, 'Adj Close')                self.adjusted_slope_360 = self.fit_curve(360, 'Adj Close')                self.get_hurst('Adj Close')            else:                self.adjusted_slope_30 = self.fit_curve(30, 'Close')                self.adjusted_slope_90 = self.fit_curve(90, 'Close')                self.adjusted_slope_180 = self.fit_curve(180, 'Close')                self.adjusted_slope_360 = self.fit_curve(360, 'Close')                self.get_hurst('Close')            self.adjusted_slope_30_vol = self.fit_curve(30, 'Volume')            self.adjusted_slope_90_vol = self.fit_curve(90, 'Volume')            self.adjusted_slope_180_vol = self.fit_curve(180, 'Volume')            self.adjusted_slope_360_vol = self.fit_curve(360, 'Volume')            self.get_hurst('Volume')            self.ATR_20 = self.data['20_days_TR'].iloc[-1]            self.MA_100 = self.data['100_days_MA'].iloc[-1]            self.MA_50 = self.data['50_days_MA'].iloc[-1]            if(self.country=='US'):                self.Adj_Close = self.data['Adj Close'].iloc[-1]                min_90 = self.data.iloc[-90:,]['Adj Close'].min()                max_90 = self.data.iloc[-90:,]['Adj Close'].max()            else:                self.Adj_Close = self.data['Close'].iloc[-1]                min_90 = self.data.iloc[-90:,]['Close'].min()                max_90 = self.data.iloc[-90:,]['Close'].max()            self.Volume = self.data['Volume'].iloc[-1]            self.close_gt_ma100 = True if self.Adj_Close >= self.MA_100 else False            self.ma50_gt_ma100 = True if self.MA_50 >= self.MA_100 else False            self.max_min =  max_90/min_90             try:                 self.position_size = np.round((port_folio_value*risk_factor )/(self.data['20_days_TR'].iloc[-1]))            except:                self.position_size = 0            if((self.close_gt_ma100) & (self.ma50_gt_ma100)  ):                    self.to_consider = True            return([self.symbol,self.to_consider,self.could_process, round(self.Adj_Close,2),round(self.adjusted_slope_30,2),round(self.adjusted_slope_90,2),round(self.adjusted_slope_180,2),round(self.adjusted_slope_360,2), self.Hurst,round(self.ATR_20,2),round(self.MA_100,2),self.position_size,self.Volume,self.close_gt_ma100,self.ma50_gt_ma100,self.max_min, round(self.adjusted_slope_30_vol,2),round(self.adjusted_slope_90_vol,2),round(self.adjusted_slope_180_vol,2),round(self.adjusted_slope_360_vol,2)])        except Exception as e:            self.could_process = False            print(self.symbol, "Error 1.... ",  e)class Indian_stock(stock):    def __init__(self,symbol):        stock.__init__(self,symbol)        self.country='IN'    def get_stock_data(self):        super().check_file()        try:            df_list=[]            for pair in self.download_dates:                df_list.append(nsepy.get_history(symbol=self.symbol,start=date(pair[0].year, pair[0].month, pair[0].day), end=date(pair[1].year, pair[1].month, pair[1].day)).reset_index()[[ 'Date','High', 'Low', 'Open' ,'Close', 'Volume']])            tmp = pd.concat(df_list)            tmp.Date = pd.to_datetime(tmp['Date']).apply(lambda x: x.date())            if(self.data is not None):                self.data.Date = pd.to_datetime(self.data.Date).apply(lambda x: x.date())                self.data = pd.concat([self.data,tmp],axis=0,sort=False).reset_index()                self.data = self.data.drop_duplicates(['Date'])            else:                self.data = tmp            self.create_stats()        except Exception as e:            print("Could not download  from get_stock_data.. ", self.symbol, e)class US_stock(stock):    def __init__(self,symbol):        stock.__init__(self,symbol)        self.country='US'    def get_stock_data(self):        super().check_file()        try:            df_list=[]            for pair in self.download_dates:                df_list.append(pdr.DataReader(name=self.symbol.replace('.','_'),data_source='yahoo', start=date(pair[0].year, pair[0].month, pair[0].day), end=date(pair[1].year, pair[1].month, pair[1].day)).reset_index())            tmp = pd.concat(df_list)            tmp.Date = pd.to_datetime(tmp['Date']).apply(lambda x: x.date())            if(self.data is not None):                self.data.Date = pd.to_datetime(self.data.Date).apply(lambda x: x.date())                self.data = pd.concat([self.data,tmp],axis=0,sort=False).reset_index()                self.data = self.data.drop_duplicates(['Date'])            else:                self.data = tmp            self.create_stats()        except Exception as e:            print("Could not download from get_stock_data in US ...  ",self.symbol, e)class process_stock_list(Indian_stock, US_stock):        def __init__(self, ticker_list=[],country_name='' ,port_folio_value=portfolio_variables.PORTFOLIO_VALUE,risk_factor = portfolio_variables.RISK_FACTOR):        self.ticker_list = ticker_list        self.country_name = country_name        self.adjusted_slopes_dictionary = pd.DataFrame()        self.port_folio_value =  port_folio_value        self.risk_factor = risk_factor        self.unprocessed_dictionary = {}        self.ignore_list =[]    def worker(self,arg):        if(self.country_name =='NSE'):            obj = Indian_stock(arg)        else:            obj = US_stock(arg)        obj.get_stock_data()        if(obj.data is not None):            return obj.get_adjusted_slope(self.port_folio_value , self.risk_factor)                    def generate_adjusted_slopes(self):        print(self.ticker_list)        print(".. in generate_adjusted_slopes function..1")        import multiprocessing as mp        pool = mp.Pool(8)        list_of_results = pool.map(self.worker, ((obj) for obj in self.ticker_list))        print(list_of_results)        list2 = [li for li in list_of_results if li is not None]        pool.close()        pool.join()        col_names=['symbol','to_consider','could_process','Adj_Close','AS_30','AS_90','AS_180','AS_360', 'Hurst' ,'ATR_20','MA_100','position_size','Volume','close_gt_ma100','ma50_gt_ma100','max_min', 'AS_30_vol', "AS_90_vol", 'AS_180_vol', 'AS_360_vol']        self.adjusted_slopes_dictionary =  pd.DataFrame(list2, columns = col_names)def get_results_data_frame(stx_list, country_name,sp500list=None):    print(" .. in results df")    process = process_stock_list(stx_list,country_name)    print("... in get results DataFrame going to generate_adjusted_slopes")    process.generate_adjusted_slopes()    Result = process.adjusted_slopes_dictionary    print(Result.head())    Result['Q_30'] = Result.AS_30.rank(pct=True)    Result['Q_90'] = Result.AS_90.rank(pct=True)    Result['Q_180'] = Result.AS_180.rank(pct=True)    Result['Q_360'] = Result.AS_360.rank(pct=True)    Result['Mean_4Q'] = round(Result[['Q_30','Q_90', 'Q_180', 'Q_360']].mean(axis=1),2)    Result['Mean_3Q'] = round(Result[['Q_90', 'Q_180', 'Q_360']].mean(axis=1),2)    Result['Mean_Q'] = Result[['Mean_3Q','Mean_4Q']].mean(axis=1)    Result['Q_30'] = round(Result['Q_30'],2)    Result['Q_90'] = round(Result['Q_90'],2)    Result['Q_180'] = round(Result['Q_180'],2)    Result['Q_360'] = round(Result['Q_360'],2)    Result['Q_30_vol'] = Result.AS_30.rank(pct=True)    Result['Q_90_vol'] = Result.AS_90.rank(pct=True)    Result['Q_180_vol'] = Result.AS_180.rank(pct=True)    Result['Q_360_vol'] = Result.AS_360.rank(pct=True)    Result['Mean_4Q_vol'] = round(Result[['Q_30_vol','Q_90_vol', 'Q_180_vol', 'Q_360_vol']].mean(axis=1),2)    Result['Mean_3Q_vol'] = round(Result[['Q_90_vol', 'Q_180_vol', 'Q_360_vol']].mean(axis=1),2)    Result['Mean_Q_vol'] = Result[['Mean_3Q_vol','Mean_4Q_vol']].mean(axis=1)    Result['Q_30_vol'] = round(Result['Q_30_vol'],2)    Result['Q_90_vol'] = round(Result['Q_90_vol'],2)    Result['Q_180_vol'] = round(Result['Q_180_vol'],2)    Result['Q_360_vol'] = round(Result['Q_360_vol'],2)    Result['Mean_Final_Q'] = Result[['Mean_Q', 'Mean_Q_vol']].mean(axis=1)    Result['Stock_Value'] = Result['position_size'] * Result['Adj_Close']    if(sp500list is not None):        Result['sp_check']= Result['symbol'].isin(sp500list)    print(Result.shape)    print(set(stx_list)- set(Result.symbol))        cf = conf.get_config(conf_dir='../csvs_n_tokens',file_name='chandra_csx_secret.json')    if(country_name =="nasdaq"):        spread = Spread('US',config=cf)    if(country_name=='NSE'):        spread = Spread('India',config=cf)    Result.sort_values(['Mean_Q'], ascending=False, inplace=True)    Result.to_csv("./"+country_name+".csv",index=False)    tmp=Result.head(n=250)    tmp=tmp[['symbol','to_consider','could_process','position_size']]    spread.df_to_sheet(tmp, index=False, sheet=datetime.datetime.now().strftime('%b-%d'))    spread.df_to_sheet(Result, index=False, sheet="all_"+datetime.datetime.now().strftime('%b-%d'))